"""
Karaoke Renderer Module for Video Project
Handles karaoke overlay generation, LRC/SRT export, and synchronization
"""

import logging
import subprocess
import json
import math
from dataclasses import dataclass
from pathlib import Path
from typing import List, Tuple, Optional, Dict, Any
from datetime import timedelta

logger = logging.getLogger(__name__)


@dataclass
class KaraokeConfig:
    """Configuration for karaoke overlay"""
    enabled: bool = False
    style: str = "bouncing_ball"  # "bouncing_ball", "highlight", "fade_in"
    position: str = "bottom"  # "bottom", "top", "center"
    font_size: int = 32
    font_color: str = "#FFFFFF"
    background_opacity: float = 0.7
    ball_image: Optional[Path] = None  # Custom ball sprite
    lead_time: float = 0.2  # Seconds before word to start animation
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return {
            'enabled': self.enabled,
            'style': self.style,
            'position': self.position,
            'font_size': self.font_size,
            'font_color': self.font_color,
            'background_opacity': self.background_opacity,
            'ball_image': str(self.ball_image) if self.ball_image else None,
            'lead_time': self.lead_time
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'KaraokeConfig':
        """Create from dictionary"""
        if data.get('ball_image'):
            data['ball_image'] = Path(data['ball_image'])
        return cls(**data)


class KaraokeRenderer:
    """Render karaoke overlays on videos and export lyrics formats"""
    
    def __init__(self, ffmpeg_path: str = "ffmpeg"):
        self.ffmpeg = ffmpeg_path
        self.logger = logging.getLogger(self.__class__.__name__)
    
    def generate_lrc(self, lyrics_timing: List[Dict[str, Any]], 
                    output_path: Path,
                    enhanced: bool = True) -> Path:
        """
        Generate LRC (Lyrics) file from timing data
        
        Args:
            lyrics_timing: List of dicts with 'time', 'text', 'duration'
            output_path: Path to save LRC file
            enhanced: Use enhanced format with word-level timing
            
        Returns:
            Path to generated LRC file
        """
        self.logger.info(f"Generating LRC file: {output_path}")
        
        lines = [
            "[ti:Generated by ImageAI]",
            "[ar:Unknown Artist]",
            "[al:Unknown Album]",
            "[by:ImageAI Video Project]",
            ""
        ]
        
        if enhanced:
            # Enhanced LRC with word-level timing
            current_line = []
            current_line_start = None
            
            for item in lyrics_timing:
                time = item['time']
                text = item['text']
                
                # Format time as [mm:ss.xx]
                minutes = int(time // 60)
                seconds = time % 60
                
                if not current_line_start:
                    current_line_start = time
                
                # Add word with timing
                current_line.append(f"<{minutes:02d}:{seconds:05.2f}>{text}")
                
                # Check if this is end of line (simple heuristic)
                if text.endswith(('.', '!', '?')) or len(current_line) >= 8:
                    # Write the line
                    line_minutes = int(current_line_start // 60)
                    line_seconds = current_line_start % 60
                    line_text = ' '.join(current_line)
                    lines.append(f"[{line_minutes:02d}:{line_seconds:05.2f}]{line_text}")
                    current_line = []
                    current_line_start = None
            
            # Add remaining words
            if current_line:
                line_minutes = int(current_line_start // 60)
                line_seconds = current_line_start % 60
                line_text = ' '.join(current_line)
                lines.append(f"[{line_minutes:02d}:{line_seconds:05.2f}]{line_text}")
        
        else:
            # Simple LRC format
            for item in lyrics_timing:
                time = item['time']
                text = item['text']
                
                # Format time as [mm:ss.xx]
                minutes = int(time // 60)
                seconds = time % 60
                
                lines.append(f"[{minutes:02d}:{seconds:05.2f}]{text}")
        
        # Write file
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))
        
        self.logger.info(f"Generated LRC with {len(lyrics_timing)} entries")
        return output_path
    
    def generate_srt(self, lyrics_timing: List[Dict[str, Any]], 
                    output_path: Path,
                    group_words: bool = True) -> Path:
        """
        Generate SRT (SubRip) subtitle file from timing data
        
        Args:
            lyrics_timing: List of dicts with 'time', 'text', 'duration'
            output_path: Path to save SRT file
            group_words: Group words into subtitle lines
            
        Returns:
            Path to generated SRT file
        """
        self.logger.info(f"Generating SRT file: {output_path}")
        
        lines = []
        subtitle_num = 1
        
        if group_words:
            # Group words into subtitle lines
            current_group = []
            group_start = None
            group_end = None
            
            for i, item in enumerate(lyrics_timing):
                if not current_group:
                    group_start = item['time']
                
                current_group.append(item['text'])
                group_end = item['time'] + item['duration']
                
                # Check if we should end this group
                end_group = False
                if item['text'].endswith(('.', '!', '?')):
                    end_group = True
                elif len(current_group) >= 8:
                    end_group = True
                elif i == len(lyrics_timing) - 1:
                    end_group = True
                elif i < len(lyrics_timing) - 1:
                    # Check if next word is far away
                    next_time = lyrics_timing[i + 1]['time']
                    if next_time - group_end > 1.0:
                        end_group = True
                
                if end_group and current_group:
                    # Write subtitle
                    lines.append(str(subtitle_num))
                    lines.append(self._format_srt_time(group_start, group_end))
                    lines.append(' '.join(current_group))
                    lines.append('')
                    
                    subtitle_num += 1
                    current_group = []
                    group_start = None
        
        else:
            # Each word as separate subtitle
            for item in lyrics_timing:
                start_time = item['time']
                end_time = start_time + item['duration']
                
                lines.append(str(subtitle_num))
                lines.append(self._format_srt_time(start_time, end_time))
                lines.append(item['text'])
                lines.append('')
                
                subtitle_num += 1
        
        # Write file
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))
        
        self.logger.info(f"Generated SRT with {subtitle_num - 1} subtitles")
        return output_path
    
    def _format_srt_time(self, start: float, end: float) -> str:
        """Format time range for SRT format"""
        def format_time(seconds: float) -> str:
            td = timedelta(seconds=seconds)
            hours = int(td.total_seconds() // 3600)
            minutes = int((td.total_seconds() % 3600) // 60)
            secs = td.total_seconds() % 60
            millis = int((secs % 1) * 1000)
            secs = int(secs)
            return f"{hours:02d}:{minutes:02d}:{secs:02d},{millis:03d}"
        
        return f"{format_time(start)} --> {format_time(end)}"
    
    def generate_ass(self, lyrics_timing: List[Dict[str, Any]], 
                    output_path: Path,
                    config: KaraokeConfig) -> Path:
        """
        Generate ASS (Advanced SubStation) file for styled karaoke
        
        Args:
            lyrics_timing: List of dicts with 'time', 'text', 'duration'
            output_path: Path to save ASS file
            config: Karaoke configuration
            
        Returns:
            Path to generated ASS file
        """
        self.logger.info(f"Generating ASS file: {output_path}")
        
        # ASS header
        lines = [
            "[Script Info]",
            "Title: Generated by ImageAI",
            "ScriptType: v4.00+",
            "Collisions: Normal",
            "PlayDepth: 0",
            "",
            "[V4+ Styles]",
            "Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding",
            f"Style: Karaoke,Arial,{config.font_size},&H00FFFFFF,&H00FF0000,&H00000000,&H80000000,0,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1",
            "",
            "[Events]",
            "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text"
        ]
        
        # Convert lyrics to ASS events
        for i, item in enumerate(lyrics_timing):
            start_time = self._format_ass_time(item['time'])
            end_time = self._format_ass_time(item['time'] + item['duration'])
            
            # Add karaoke effect based on style
            if config.style == "highlight":
                # Highlight effect
                text = f"{{\\k{int(item['duration'] * 100)}}}{item['text']}"
            elif config.style == "fade_in":
                # Fade in effect
                text = f"{{\\fad(200,0)}}{item['text']}"
            else:
                # Default
                text = item['text']
            
            lines.append(f"Dialogue: 0,{start_time},{end_time},Karaoke,,0,0,0,,{text}")
        
        # Write file
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))
        
        self.logger.info(f"Generated ASS with {len(lyrics_timing)} events")
        return output_path
    
    def _format_ass_time(self, seconds: float) -> str:
        """Format time for ASS format (h:mm:ss.cc)"""
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = seconds % 60
        centisecs = int((secs % 1) * 100)
        secs = int(secs)
        return f"{hours}:{minutes:02d}:{secs:02d}.{centisecs:02d}"
    
    def add_bouncing_ball_overlay(self, video_path: Path,
                                  lyrics_timing: List[Dict[str, Any]],
                                  output_path: Path,
                                  config: KaraokeConfig) -> Path:
        """
        Add bouncing ball karaoke overlay to video using FFmpeg
        
        Args:
            video_path: Input video file
            lyrics_timing: List of dicts with 'time', 'text', 'duration'
            output_path: Output video path
            config: Karaoke configuration
            
        Returns:
            Path to output video with overlay
        """
        self.logger.info(f"Adding bouncing ball overlay to video")
        
        # Create a temporary SRT file for the lyrics
        srt_path = output_path.parent / "temp_lyrics.srt"
        self.generate_srt(lyrics_timing, srt_path, group_words=True)
        
        # Build FFmpeg filter complex
        filters = []
        
        # Add subtitles
        subtitle_filter = f"subtitles={srt_path}:force_style='"
        subtitle_filter += f"Fontsize={config.font_size},"
        subtitle_filter += f"PrimaryColour=&H{config.font_color[1:]}FF&,"
        
        # Position
        if config.position == "top":
            subtitle_filter += "Alignment=2,"
        elif config.position == "center":
            subtitle_filter += "Alignment=5,"
        else:  # bottom
            subtitle_filter += "Alignment=2,"
        
        subtitle_filter += "'"
        filters.append(subtitle_filter)
        
        # If we have a ball image, add bouncing animation
        if config.ball_image and config.ball_image.exists():
            # This would require more complex filter chains
            # For now, we'll use a simple overlay approach
            pass
        
        # Build FFmpeg command
        cmd = [
            self.ffmpeg, "-y",
            "-i", str(video_path),
            "-vf", ','.join(filters),
            "-c:a", "copy",  # Copy audio unchanged
            str(output_path)
        ]
        
        try:
            self.logger.debug(f"Running FFmpeg: {' '.join(cmd)}")
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            self.logger.info(f"Created karaoke video: {output_path}")
            
            # Clean up temp file
            if srt_path.exists():
                srt_path.unlink()
            
            return output_path
            
        except subprocess.CalledProcessError as e:
            self.logger.error(f"FFmpeg failed: {e.stderr}")
            raise RuntimeError(f"Failed to add karaoke overlay: {e.stderr}")
    
    def create_animated_lyrics_video(self, video_path: Path,
                                    lyrics_timing: List[Dict[str, Any]],
                                    output_path: Path,
                                    config: KaraokeConfig,
                                    audio_path: Optional[Path] = None) -> Path:
        """
        Create a video with animated lyrics overlay
        
        Args:
            video_path: Base video or image sequence
            lyrics_timing: Lyrics with timing information
            output_path: Output video path
            config: Karaoke configuration
            audio_path: Optional audio track to include
            
        Returns:
            Path to generated video
        """
        self.logger.info("Creating animated lyrics video")
        
        # For now, use simple subtitle overlay
        # In production, you'd want more sophisticated animation
        output = self.add_bouncing_ball_overlay(video_path, lyrics_timing, output_path, config)
        
        # Add audio if provided
        if audio_path and audio_path.exists():
            final_output = output_path.parent / f"final_{output_path.name}"
            cmd = [
                self.ffmpeg, "-y",
                "-i", str(output),
                "-i", str(audio_path),
                "-c:v", "copy",
                "-c:a", "aac",
                "-shortest",
                str(final_output)
            ]
            
            try:
                subprocess.run(cmd, capture_output=True, check=True)
                output.unlink()  # Remove intermediate file
                final_output.rename(output_path)
                self.logger.info(f"Added audio track to video")
            except subprocess.CalledProcessError as e:
                self.logger.error(f"Failed to add audio: {e}")
        
        return output_path